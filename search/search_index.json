{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p> Follow DRY principles and keep your code DRY with FastRDB FastRDB  is a high-performance, generic CRUD operations package combining SQLAlchemy async ORM with Redis caching. </p>"},{"location":"#features","title":"Features","text":"<ul> <li>Type-Safe CRUD Operations: Built with Python type hints and generics for robust type checking</li> <li>SQLAlchemy Integration: Seamless integration with SQLAlchemy for database operations</li> <li>Redis Caching: Integrated Redis caching with automatic cache invalidation</li> <li>Async Support: Fully asynchronous operations using SQLAlchemy async ORM and Redis</li> <li>Pagination: Built-in pagination support with customizable limits and page numbers</li> <li>Pydantic Integration: Seamless integration with Pydantic for schema validation</li> <li>Generic Base Class: Extensible base class for creating custom CRUD operations</li> <li>Automatic Cache Management: Smart cache invalidation on data modifications</li> <li>Error Handling: Consistent error handling with custom exceptions</li> </ul>"},{"location":"#requirements","title":"Requirements","text":"<ul> <li>Python 3.10 or higher</li> <li>SQLAlchemy</li> <li>Redis</li> <li>Pydantic</li> <li>orjson</li> </ul> <p>You only need to ensure Python version compatibility. All other dependencies will be installed automatically with FastRDB.</p>"},{"location":"#installation","title":"Installation","text":"<ul> <li>Using uv</li> </ul> <p>First create a virtual environment and activate it  (if not already done and it's a good practice to keep your dependencies in a virtual environment)  :</p> <pre><code>uv venv\nsource .venv/bin/activate \n</code></pre> <p>Install FastRDB: <pre><code>uv pip install fastrdb\n</code></pre></p> <ul> <li>Using pip</li> </ul> <p>Create a virtual environment and activate it:</p> <p><pre><code>python3 -m venv venv\nsource venv/bin/activate\n</code></pre> Install FastRDB:</p> <p><pre><code>pip install fastrdb\n</code></pre> Now you are ready to use FastRDB! \ud83e\udd29</p>"},{"location":"#tutorial","title":"Tutorial","text":"<p>Click here to see a complete example</p>"},{"location":"tutorial/","title":"Tutorial","text":""},{"location":"tutorial/#create-a-database-connection","title":"Create A Database Connection","text":"<pre><code># db.py\nfrom typing import AsyncGenerator\nfrom sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker\nfrom sqlalchemy.ext.asyncio.session import AsyncSession\nfrom sqlalchemy.orm import DeclarativeBase, MappedAsDataclass\n\n# Dummy database config\nDB_DRIVER = \"sqlite+aiosqlite\"\nDB_NAME = \"example.db\"\nDATABASE_URL = f\"{DB_DRIVER}:///{DB_NAME}\"  # sqlite+aiosqlite:///example.db\n\n# Base class for models\nclass Base(MappedAsDataclass, DeclarativeBase):\n    pass\n\n# Async engine and session factory\nasync_engine = create_async_engine(DATABASE_URL, echo=True)\nlocal_session = async_sessionmaker(\n    async_engine,\n    expire_on_commit=False,\n    class_=AsyncSession,\n    autoflush=False,\n    autocommit=False\n)\n\nasync def async_get_db() -&gt; AsyncGenerator[AsyncSession, None]:\n    async with local_session() as session:\n        try:\n            await session.commit()\n            yield session\n        finally:\n            await session.close()\n</code></pre>"},{"location":"tutorial/#create-a-sqlalchemy-model","title":"Create A SqlAlchemy Model","text":"<pre><code># models.py\nfrom sqlalchemy.orm import Mapped, mapped_column\nfrom sqlalchemy import String, Boolean\nfrom db import Base\n\nclass User(Base):\n    __tablename__ = \"users\"\n\n    id: Mapped[int] = mapped_column(primary_key=True, autoincrement=True)\n    email: Mapped[str] = mapped_column(String(255), nullable=False, unique=True, index=True)\n    name: Mapped[str] = mapped_column(String(100), nullable=False)\n    bio: Mapped[str] = mapped_column(String(500), nullable=True)\n\n    created_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), server_default=func.now(), nullable=False)\n    updated_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), onupdate=func.now(), server_default=func.now(), nullable=False)\n\n    is_active: Mapped[bool] = mapped_column(Boolean, nullable=False, default=True)\n</code></pre>"},{"location":"tutorial/#create-required-pydantic-schemasmodels","title":"Create required Pydantic schemas/models","text":"<pre><code># schemas.py\nfrom pydantic import BaseModel, EmailStr\nfrom typing import Optional\nfrom datetime import datetime\n\nclass UserCreate(BaseModel):\n    email: EmailStr\n    name: str\n    bio: Optional[str] = None\n    is_active: bool = True\n\nclass UserUpdate(BaseModel):\n    email: Optional[EmailStr] = None\n    name: Optional[str] = None\n    bio: Optional[str] = None\n    is_active: Optional[bool] = None\n\nclass UserResponse(BaseModel):\n    id: int\n    email: str\n    name: str\n    bio: Optional[str] = None\n    is_active: bool\n    created_at: datetime\n    updated_at: datetime\n\n    class Config:\n        from_attributes = True \n</code></pre>"},{"location":"tutorial/#now-initialize-fastrdb","title":"Now Initialize FastRDB","text":"<pre><code># crud.py\nfrom fastrdb import FastRDB\nfrom models import User\nfrom schemas import UserCreate, UserUpdate, UserResponse\n\nuser_crud = FastRDB[User, UserCreate, UserUpdate, UserResponse](\n    User, \n    UserResponse,   \n    pattern=\"user:email:{email}\",\n    list_pattern=\"user:page:{page}:limit:{limit}\",\n    invalidate_pattern_prefix=\"todo:*\",\n    exp=6000\n)\n</code></pre>"},{"location":"tutorial/#args-explanations","title":"Args Explanations:","text":"<ul> <li> <p>Generic type arguments [...]</p> <ul> <li>ModelType: SQLAlchemy model (e.g., Item) representing the DB table</li> <li>CreateSchemaType: Pydantic schema for creation operations</li> <li>UpdateSchemaType: Pydantic schema for update operations</li> <li>ResponseSchemaType: Pydantic schema for response serialization</li> </ul> </li> <li> <p>Constructor arguments (...):</p> <ul> <li>Model : SQLAlchemy model class</li> <li>ResponseSchema : Pydantic model for response serialization</li> <li>pattern : Used for caching a single object (like one user)     <pre><code>pattern=\"user:email:{email}\"\n</code></pre>     What it means:<ul> <li>This pattern creates a unique Redis key for each individual item.</li> <li>The placeholder ({email} will be replaced by actual values at runtime. Example key:     <pre><code>user:email:john@example.com\n</code></pre></li> </ul> </li> <li> <p>list_pattern :  Used for caching a list of objects (like paginated results)     <pre><code>list_pattern = \"user:page:{page}:limit:{limit}\"\n</code></pre>     What it means:</p> <ul> <li>This creates a Redis key for a specific page of a list.</li> <li>Example key:     <pre><code>user:page:1:limit:10\n</code></pre></li> </ul> </li> <li> <p>invalidate_pattern_prefix :Used to invalidate multiple related keys at once     <pre><code>invalidate_pattern_prefix=\"user:*\"\n</code></pre>     What it means:</p> <ul> <li>This sets up a prefix for cache keys that should be cleared when data is updated or deleted.</li> <li>Example key:     <pre><code>user:*\n</code></pre></li> </ul> </li> <li> <p>exp: Redis expiration time</p> </li> </ul> </li> </ul>"},{"location":"tutorial/#now-create-async-redis-client","title":"Now Create Async Redis Client","text":"<pre><code># redis_client.py\nfrom redis.asyncio import Redis\nfrom typing import AsyncGenerator\n\nredis_host = \"localhost\"           \nredis_port = 6379          \nredis_db = 0\nredis_decode_responses = True \n\nredis_client = Redis(\n    host=redis_host,\n    port=redis_port,\n    db=redis_db,\n    decode_responses=redis_decode_responses\n)\n\nasync def get_redis() -&gt; AsyncGenerator[Redis, None]:\n    try:\n        yield redis_client\n    finally:\n        await redis_client.close()\n</code></pre>"},{"location":"tutorial/#now-we-are-ready-to-use-the-fastrdb-class","title":"Now we are ready to use the FastRDB class","text":"<ul> <li> <p>In this example, we'll create a FastAPI app to manage items.(But you can use it anywhere) <pre><code># main.py\nfrom fastapi import FastAPI, Depends\nfrom sqlalchemy.ext.asyncio import AsyncSession\nfrom redis.asyncio import Redis\n\nfrom redis_client import get_redis\nfrom crud import user_crud\nfrom models import User\nfrom schemas import UserCreate, UserUpdate, UserResponse\nfrom db import async_get_db\n\napp = FastAPI()\n\n@app.post(\"/users/\", response_model=UserResponse)\nasync def create_user(user: UserCreate, redis: Redis = Depends(get_redis), db: AsyncSession = Depends(async_get_db)) -&gt; UserResponse:\n    return await user_crud.create(db=db, redis=redis, obj_in=user , email=user.email)\n</code></pre></p> </li> <li> <p>If you want to use without FastAPI:</p> </li> </ul> <pre><code># main.py\nfrom redis_client import get_redis\nfrom crud import user_crud\nfrom models import User\nfrom schemas import UserCreate, UserUpdate, UserResponse\nfrom db import async_get_db\n\nasync def create_user(user: UserCreate) -&gt; UserResponse:\n    async with get_redis() as redis, async_get_db() as db:\n        return await user_crud.create(db=db, redis=redis, obj_in=user , email=user.email)\n</code></pre>"},{"location":"tutorial/#all-methods","title":"All Methods","text":""},{"location":"tutorial/#create","title":"<code>create</code>","text":"<ul> <li>Creates a new record in the database and caches it in Redis.<ul> <li>args : <code>db: AsyncSession, redis: Redis, obj_in: CreateSchema, **kwargs: Any</code></li> <li>Explanation:<ul> <li><code>db: AsyncSession</code>: An async SQLAlchemy session.</li> <li><code>redis: Redis</code>: An async Redis client.</li> <li><code>obj_in: CreateSchema</code>: An instance of the create schema.</li> <li><code>**kwargs: Any</code>: Keyword arguments for matching redis pattern. Like you have set <code>pattern=\"user:email:{email}\"</code> then you will pass <code>email=\"john@example.com\"</code> here.</li> </ul> </li> <li>Returns : <code>ResponseSchemaType</code></li> <li>Example :     <pre><code>db = AsyncSession(...)  # Your SQLAlchemy async session\nredis = Redis(...)      # Your Redis client\nuser = UserCreate(name=\"John Doe\", email=\"john@example.com\" , bio=\"Hello World\")\nawait user_crud.create(db=db, redis=redis, obj_in=user , email=user.email)\n</code></pre></li> </ul> </li> </ul>"},{"location":"tutorial/#get","title":"<code>get</code>","text":"<ul> <li>Retrieves a single record from the database and caches it in Redis.<ul> <li>args : <code>db: AsyncSession, redis: Redis, **kwargs: Any</code></li> <li>Explanation:<ul> <li><code>db: AsyncSession</code>: An async SQLAlchemy session.</li> <li><code>redis: Redis</code>: An async Redis client.</li> <li><code>**kwargs: Any</code>: Keyword arguments used for matching the Redis key pattern and filtering the record from the database.<ul> <li>If your Redis key pattern is set as pattern=\"user:email:{email}\", you must pass email=\"john@example.com\" in kwargs.</li> <li>These keyword arguments will be used both to format the Redis key and to filter the database query.</li> <li>You can include additional filters, but it is mandatory to provide all fields required by the Redis key pattern.</li> </ul> </li> </ul> </li> <li>Returns : <code>ResponseSchemaType</code> </li> <li>Raises : <code>NoResultFound</code> from SQLAlchemy</li> <li>Example :     <pre><code>from sqlalchemy.orm.exc import NoResultFound\ndb = AsyncSession(...)  # Your SQLAlchemy async session\nredis = Redis(...)      # Your Redis client\ntry:\n    user = await user_crud.get(db=db, redis=redis, email=\"john@example.com\")\nexcept NoResultFound:\n    # Handle the case where no user is found\n    ...\n</code></pre></li> </ul> </li> </ul>"},{"location":"tutorial/#update","title":"<code>update</code>","text":"<ul> <li>Updates a record in the database and caches the updated record in Redis.<ul> <li>args : <code>db: AsyncSession, redis: Redis, obj_in: UpdateSchema, **kwargs: Any</code></li> <li>Explanation:<ul> <li><code>db: AsyncSession</code>: An async SQLAlchemy session.</li> <li><code>redis: Redis</code>: An async Redis client.</li> <li><code>obj_in: UpdateSchema</code>: An instance of the update schema.</li> <li><code>**kwargs: Any</code>: Keyword arguments  for filtering the record to update.<ul> <li>If your Redis key pattern is set as pattern=\"user:email:{email}\", you must pass email=\"john@example.com\" in kwargs.</li> <li>These keyword arguments will be used both to format the Redis key and to filter the database query.</li> <li>You can include additional filters, but it is mandatory to provide all fields required by the Redis key pattern.</li> </ul> </li> </ul> </li> <li>Returns : <code>ResponseSchemaType</code> </li> <li>Example :     <pre><code>db = AsyncSession(...)  # Your SQLAlchemy async session\nredis = Redis(...)      # Your Redis client\nuser = UserUpdate(name=\"John Doe\")\nawait user_crud.update(db=db, redis=redis, obj_in=user , email=\"john@example.com\")\n</code></pre></li> </ul> </li> </ul>"},{"location":"tutorial/#get_multi","title":"<code>get_multi</code>","text":"<ul> <li>Retrieves multiple records from the database and caches them in Redis.<ul> <li>args : <code>db: AsyncSession, redis: Redis, limit : int = 10 , page : int = 1 , order_by : Optional[str] = None , ascending : bool = True , **kwargs: Any</code></li> <li>Explanation:<ul> <li><code>db: AsyncSession</code>: An async SQLAlchemy session.</li> <li><code>redis: Redis</code>: An async Redis client.</li> <li><code>limit : int = 10</code>: Number of records per page.</li> <li><code>page : int = 1</code>: Current page number.</li> <li><code>order_by : Optional[str] = None</code>: Field to order by.<ul> <li><code>order_by</code> must be a valid model attribute.</li> <li>If you have a SqlAlchemy model field <code>id</code> then you can use <code>order_by=\"id\"</code>. It will fetch records from database sorted by <code>id</code> in ascending(default) order.</li> </ul> </li> <li><code>ascending : bool = True</code>: Sort direction. True for ascending (default), False for descending.</li> <li><code>**kwargs: Any</code>: Keyword arguments for filtering the records.<ul> <li>If your Redis key list_pattern is set as list_pattern=\"user:page:{page}:limit:{limit}\" , you must pass page=1 and limit=10 in kwargs.However in this case the page and limit already has default value so you are not passing as keyword arg but you have to use it like this. </li> </ul> </li> </ul> </li> <li>Returns : <code>List[ResponseSchemaType]</code></li> <li>Example :     <pre><code>db = AsyncSession(...)  # Your SQLAlchemy async session\nredis = Redis(...)      # Your Redis client\nusers = await user_crud.get_multi(db=db, redis=redis, limit=10, page=1 , order_by=\"id\")\n\n\n# Another Example\n# verse_crud = FastRDB[Verse, VerseCreate, VerseUpdate, VerseResponse](\n# Verse, \n# VerseResponse,   \n# pattern=\"verse:chapter_id:{chapter_id}:verse_id:{verse_id}\",\n# list_pattern=\"verse:chapter_id:{chapter_id}:page:{page}:limit:{limit}\",\n# invalidate_pattern_prefix=\"verse:chapter_id:{chapter_id}:*\",\n# exp=6000)\n\nverses = await verse_crud.get_multi(\ndb=db,\nredis=redis,\nlimit=20,\npage=1,\norder_by=\"verse_id\",\nchapter_id=3) # it will fetch records from database sorted by `verse_id` in ascending order and filtered by `chapter_id`\n    # and list_pattern=\"verse:chapter:{chapter_id}:page:{page}:limit:{limit}\"9\n</code></pre></li> </ul> </li> </ul>"},{"location":"tutorial/#create_multi","title":"<code>create_multi</code>","text":"<ul> <li>Creates multiple records in the database.<ul> <li>args : <code>db: AsyncSession, redis: Redis, instances: List[CreateSchema]</code></li> <li>Explanation:<ul> <li><code>db: AsyncSession</code>: An async SQLAlchemy session.</li> <li><code>redis: Redis</code>: An async Redis client.</li> <li><code>instances: List[CreateSchema]</code>: A list of instances of the create schema.</li> <li><code>**kwargs : Any</code>: Keyword arguments for matching redis pattern.</li> </ul> </li> <li>Returns : <code>List[ResponseSchemaType]</code></li> <li>Example : <pre><code>db = AsyncSession(...)  # Your SQLAlchemy async session\nredis = Redis(...)      # Your Redis client\nusers = [\n    UserCreate(name=\"John Doe\", email=\"john@example.com\" , bio=\"Hello World\"),\n    UserCreate(name=\"Jane Doe\", email=\"jane@example.com\" , bio=\"Hello World\")]\nawait user_crud.create_multi(db=db, redis=redis, instances=users)\n</code></pre></li> </ul> </li> </ul>"},{"location":"tutorial/#delete","title":"<code>delete</code>","text":"<ul> <li>Deletes a record from the database and invalidates the cache.<ul> <li>args : <code>db: AsyncSession, redis: Redis, **kwargs: Any</code></li> <li>Explanation:<ul> <li><code>db: AsyncSession</code>: An async SQLAlchemy session.</li> <li><code>redis: Redis</code>: An async Redis client.</li> <li><code>**kwargs: Any</code>: Keyword arguments used for matching the Redis key pattern and filtering the record from the database.<ul> <li>If your Redis key <code>pattern</code> is set as pattern=\"user:email:{email}\", you must pass email=\"john@example.com\" in kwargs.</li> <li>make sure arg maches your <code>invalidate_pattern_prefix</code> like invalidate_pattern_prefix=\"user:email:{email}\" then you must pass email=\"john@example.com\"</li> <li>These keyword arguments will be used both to format the Redis key and to filter the database query.</li> <li>You can include additional filters, but it is mandatory to provide all fields required by the Redis key pattern.</li> </ul> </li> </ul> </li> <li>Returns : None</li> <li>Example :     <pre><code>db = AsyncSession(...)  # Your SQLAlchemy async session\nredis = Redis(...)      # Your Redis client\nawait user_crud.delete(db=db, redis=redis, email=\"john@example.com\")\n</code></pre></li> </ul> </li> </ul>"},{"location":"tutorial/#count","title":"<code>count</code>","text":"<ul> <li>Counts the number of records in the database.<ul> <li>args : <code>db: AsyncSession, redis: Redis, **kwargs: Any</code></li> <li>Explanation:<ul> <li><code>db: AsyncSession</code>: An async SQLAlchemy session.</li> <li><code>**kwargs: Any</code>: Keyword arguments used for filtering the records from the database.</li> </ul> </li> <li>Returns: count of data</li> <li>Example : <pre><code>db = AsyncSession(...)  # Your SQLAlchemy async session\nawait user_crud.count(db=db, email=\"john@example.com\")\n</code></pre></li> </ul> </li> </ul>"},{"location":"tutorial/#paginate","title":"<code>paginate</code>","text":"<ul> <li>Returns a paginated response for a given list of data.<ul> <li>args : <code>data : List[Any] , limit : int , page : int</code><ul> <li>data: List[Any] \u2013 A list of items (usually model instances) to paginate.</li> <li>limit: int \u2013 The maximum number of items per page.</li> <li>page : int \u2013 The current page number.</li> </ul> </li> <li>Returns: <code>List[Any]</code><ul> <li>PaginatedResponse[Any] \u2013 A Pydantic model containing:</li> <li>data: Sublist of items for the requested page.</li> <li>total: Total number of items across all pages.</li> <li>limit: Number of items per page (as provided).</li> <li>page: Current page number (as provided).</li> </ul> </li> <li>Example : <pre><code>users = await user_crud.get_multi(db=db, redis=redis, limit=10, page=1 , order_by=\"id\")\nreturn verse_crud.paginate(data=users, limit=limit, page=page)\n</code></pre></li> </ul> </li> </ul>"},{"location":"tutorial/#conclusion","title":"Conclusion","text":"<p>You've now set up a FastRDB instance and can start using it for your database operations.</p>"},{"location":"tutorial/#thanks-for-following-along","title":"Thanks for following along!","text":"<ul> <li>If this helped you, consider giving the project a \u2b50\ufe0f, sharing it, or contributing to future improvements. Happy Coding!</li> <li>Github: biisal/fastrdb</li> <li>Contact : +917029881540</li> </ul>"}]}